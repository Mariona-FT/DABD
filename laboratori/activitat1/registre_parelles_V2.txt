Considerem que gestionem un registre de parelles de fet (unions i separacions
de parelles de fet) mitjançant una única relació, amb els següents atributs:

* Dni del 1er membre
* Sexe del 1er membre (M o F)
* Dni del 2on membre
* Sexe del 2on membre (M o F)
* Data del registre
* Tipus de registre (UNI o SEP)
* Ciutat del registre
* Comarca del registre

CREATE TABLE registre (
  dni1 char(6),
  sex1 char(1) CHECK(sex1 IN ('M','F')),
  dni2 char(6),
  sex2 char(1) CHECK(sex2 IN ('M','F')),
  rdate date,
  type char(3) CHECK(type IN ('UNI','SEP')),
  city varchar(50),
  district varchar(50)
);


Les persones es distingeixen pel seu dni, les ciutats i comarques pel seu nom.

Una mateixa parella es pot registrar vàries vegades, tant per unir-se com per
separar-se, però mai en la mateixa data. Evidentment, les parelles que es
separen ho fan en una data posterior a la de la seva unió i no necessàriament
a la mateixa ciutat on es van unir. Les parelles poden ser del mateix sexe.


1) Crea les queries que responguin les següents preguntes (una sola query per
cada pregunta).

1.a) Número de separacions de cada ciutat
SELECT city, COUNT(*) AS num_separacions
FROM registre
WHERE type = 'SEP'
GROUP BY city
ORDER BY num_separacions DESC;

1.b) Els dos anys en que hi ha menys separacions
SELECT YEAR(rdate) AS any, COUNT(*) AS num_separacions
FROM registre
WHERE type = 'SEP'
GROUP BY YEAR(rdate)
ORDER BY num_separacions ASC
LIMIT 2;

1.c) Anys en que el número d'unions és diferent al de separacions
SELECT unions.any,
       unions.num_unions,
       separacions.num_separacions
FROM
  (SELECT YEAR(rdate) AS any, COUNT(*) AS num_unions
   FROM registre
   WHERE type = 'UNI'
   GROUP BY YEAR(rdate)) AS unions
LEFT JOIN
  (SELECT YEAR(rdate) AS any, COUNT(*) AS num_separacions
   FROM registre
   WHERE type = 'SEP'
   GROUP BY YEAR(rdate)) AS separacions
ON unions.any = separacions.any
WHERE unions.num_unions <> separacions.num_separacions
   OR separacions.num_separacions IS NULL
UNION
SELECT separacions.any,
       unions.num_unions,
       separacions.num_separacions
FROM
  (SELECT YEAR(rdate) AS any, COUNT(*) AS num_unions
   FROM registre
   WHERE type = 'UNI'
   GROUP BY YEAR(rdate)) AS unions
RIGHT JOIN
  (SELECT YEAR(rdate) AS any, COUNT(*) AS num_separacions
   FROM registre
   WHERE type = 'SEP'
   GROUP BY YEAR(rdate)) AS separacions
ON unions.any = separacions.any
WHERE unions.num_unions <> separacions.num_separacions
   OR unions.num_unions IS NULL
ORDER BY any;
Aquesta consulta realitza els passos següents:

Crea una subconsulta (unions) que selecciona l'any i el nombre d'unions (num_unions) per cada any.
Crea una altra subconsulta (separacions) que selecciona l'any i el nombre de separacions (num_separacions) per cada any.
Utilitza un LEFT JOIN per unir les dues subconsultes per any, i després filtra els resultats on el nombre d'unions i separacions és diferent o on no hi ha registre de separacions per aquest any (separacions.num_separacions IS NULL).
Repeteix el procés amb un RIGHT JOIN per capturar els anys on hi ha registres de separacions però no d'unions.
Utilitza UNION per combinar els resultats de les dues unions anteriorment mencionades.
Ordena els resultats per any amb ORDER BY any.


1.d) Número de parelles que s'han separat a diferent comarca en la que es van unir
SELECT COUNT(DISTINCT unio.dni1, unio.dni2) AS num_parelles_separades_diferent_comarca
FROM
  (SELECT dni1, dni2, district AS comarca_unio
   FROM registre
   WHERE type = 'UNI') AS unio
JOIN
  (SELECT dni1, dni2, district AS comarca_separacio
   FROM registre
   WHERE type = 'SEP') AS separacio
ON unio.dni1 = separacio.dni1 AND unio.dni2 = separacio.dni2
WHERE unio.comarca_unio <> separacio.comarca_separacio;


1.e) Quina parella de les que s'han separat ha durat més dies?
SELECT 
    unio.dni1, 
    unio.dni2, 
    MAX(separacio.rdate) - MIN(unio.rdate) AS dies_durada
FROM 
    registre AS unio
JOIN 
    registre AS separacio ON unio.dni1 = separacio.dni1 AND unio.dni2 = separacio.dni2
WHERE 
    unio.type = 'UNI' AND separacio.type = 'SEP'
GROUP BY 
    unio.dni1, unio.dni2
ORDER BY 
    dies_durada DESC
LIMIT 1;



2) Quines dependències funcionals (D.F.) té el problema? Usa els mateixos noms
d'atributs que els que apareixen a la taula.

Per abordar aquest problema, primer identificarem les dependències funcionals (D.F.) presents en la descripció del problema, i després procedirem a crear un esquema de base de dades normalitzat fins a la Tercera Forma Normal (3FN).

Dependències Funcionals (D.F.)
Considerant l'estructura de la taula i la descripció proporcionada, les següents dependències funcionals s'apliquen al context de la gestió de parelles de fet:

{dni1, dni2, rdate} -> {sex1, sex2, type, city, district}: La combinació dels DNIs dels membres de la parella i la data del registre determina de manera única els atributs de sexe dels membres, el tipus de registre (unió o separació), la ciutat i la comarca del registre.
{dni1} -> {sex1}: El DNI del primer membre determina de manera única el seu sexe.
{dni2} -> {sex2}: El DNI del segon membre determina de manera única el seu sexe.
{city} -> {district}: La ciutat determina de manera única la comarca (això pot ser cert en alguns contextos, però en la realitat pot haver ciutats amb el mateix nom en comarques diferents; per aquest exercici, assumirem que cada ciutat pertany a una sola comarca).


3) A partir de les D.F. anteriors, crea les taules adequades per tal que
estiguin normalitzades en 3FN. Recorda de definir les claus primàries,
alternatives i foranes, les polítiques ON DELETE i ON UPDATE de les claus
foranes i si els atributs són NOT NULL.

CREATE TABLE Persones (
    dni CHAR(6) NOT NULL,
    sex CHAR(1) NOT NULL CHECK (sex IN ('M', 'F')),
    PRIMARY KEY (dni)
);

CREATE TABLE Ciutats (
    city VARCHAR(50) NOT NULL,
    district VARCHAR(50) NOT NULL,
    PRIMARY KEY (city)
    -- Suposem que cada ciutat només pertany a una comarca.

);

CREATE TABLE Registres (
    dni1 CHAR(6) NOT NULL,
    dni2 CHAR(6) NOT NULL,
    rdate DATE NOT NULL,
    type CHAR(3) NOT NULL CHECK (type IN ('UNI', 'SEP')),
    city VARCHAR(50) NOT NULL,
    PRIMARY KEY (dni1, dni2, rdate),
    FOREIGN KEY (dni1) REFERENCES Persones(dni)
        ON DELETE CASCADE 
        ON UPDATE CASCADE,
    FOREIGN KEY (dni2) REFERENCES Persones(dni)
        ON DELETE CASCADE 
        ON UPDATE CASCADE,
    FOREIGN KEY (city) REFERENCES Ciutats(city)
        ON DELETE RESTRICT 
        ON UPDATE CASCADE
    -- Aquesta configuració permet actualitzacions en cascada per les referències, però restringeix l'eliminació de ciutats que estiguin en ús.
);


Es recomanable posar en les taules normalitzades els mateixos noms d'atributs
que els de la taula original, així et serà més fàcil transferir les dades.
Tens llibertat per triar els noms de la taules normalitzades, però intenta que
siguin noms adequats, que expressin el concepte que emmagatzemen.

4) Trasllada les dades de la taula original a les taules normalitzades.

5) Resol les mateixes queries de l'apartat 1) sobre les taules normalitzades.

5.a) Número de separacions de cada ciutat
SELECT 
    Ciutats.city, 
    Ciutats.district, 
    COUNT(*) AS num_separacions
FROM 
    Registres
JOIN 
    Ciutats ON Registres.city = Ciutats.city
WHERE 
    Registres.type = 'SEP'
GROUP BY 
    Ciutats.city, Ciutats.district
ORDER BY 
    num_separacions DESC;

5.b) Els dos anys en que hi ha menys separacions

SELECT 
    EXTRACT(YEAR FROM rdate) AS any, 
    COUNT(*) AS num_separacions
FROM 
    Registres
WHERE 
    type = 'SEP'
GROUP BY 
    EXTRACT(YEAR FROM rdate)
ORDER BY 
    num_separacions ASC
LIMIT 2;

5.c) Anys en que el número d'unions és diferent al de separacions
SELECT 
    EXTRACT(YEAR FROM rdate) AS any,
    SUM(CASE WHEN type = 'UNI' THEN 1 ELSE 0 END) AS num_unions,
    SUM(CASE WHEN type = 'SEP' THEN 1 ELSE 0 END) AS num_separacions
FROM 
    Registres
GROUP BY 
    EXTRACT(YEAR FROM rdate)
HAVING 
    SUM(CASE WHEN type = 'UNI' THEN 1 ELSE 0 END) <> SUM(CASE WHEN type = 'SEP' THEN 1 ELSE 0 END)
ORDER BY 
    any;

5.d) Número de parelles que s'han separat a diferent comarca en la que es van unir
SELECT COUNT(DISTINCT r1.dni1, r1.dni2) AS parelles_separades_diferent_comarca
FROM Registres r1
JOIN Registres r2 ON r1.dni1 = r2.dni1 AND r1.dni2 = r2.dni2
JOIN Ciutats c1 ON r1.city = c1.city
JOIN Ciutats c2 ON r2.city = c2.city
WHERE r1.type = 'UNI' AND r2.type = 'SEP' 
AND c1.district <> c2.district;

5.e) Quina parella de les que s'han separat ha durat més dies?
SELECT r1.dni1, r1.dni2, MAX(r2.rdate - r1.rdate) AS max_dies_durada
FROM Registres r1
JOIN Registres r2 ON r1.dni1 = r2.dni1 AND r1.dni2 = r2.dni2
WHERE r1.type = 'UNI' AND r2.type = 'SEP'
GROUP BY r1.dni1, r1.dni2
ORDER BY max_dies_durada DESC
LIMIT 1;

